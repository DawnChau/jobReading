### 1. SpringCloud和Dubbo

- SpringCloud和Dubbo都是现在主流的微服务架构
- SpringCloud是Apache旗下的Spring体系下的微服务解决方案。Dubbo是阿里系的分布式服务治理框架
- 从技术维度上，其实SpringCloud远远的超过Dubbo，Dubbo本身只是实现了服务治理，而SpringCloud现在以及有21个子项目以后还会更多，所以其实很多人都会说Dubbo和SpringCloud是不公平的。但是由于RPC以及注册中心元数据等原因，在技术选型的时候我们只能二者选其一，所以我们常常为用他俩来对比。
- 服务的调用方式**Dubbo使用的是RPC远程调用**，**而SpringCloud使用的是 Rest API**，其实更符合微服务官方的定义
- **服务的注册中心来看，Dubbo使用了第三方的ZooKeeper作为其底层的注册中心，实现服务的注册和发现，SpringCloud使用Spring Cloud Netflix Eureka实现注册中心，当然SpringCloud也可以使用ZooKeeper实现，但一般我们不会这样做**
- 服务网关，Dubbo并没有本身的实现，只能通过其他第三方技术的整合，而**SpringCloud有Zuul路由网关**，作为路由服务器，进行消费者的请求分发，**SpringCloud还支持断路器，与git完美集成分布式配置文件支持版本控制**，事务总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素

### 2. Rest和RPC对比

- 其实如果仔细阅读过微服务提出者马丁福勒的论文的话可以发现其定义的服务间通信机制就是Http Rest。**RPC最主要的缺陷就是服务提供方和调用方式之间依赖太强，我们需要为每一个微服务进行接口的定义，并通过持续继承发布，需要严格的版本控制才不会出现服务提供和调用之间因为版本不同而产生的冲突**，而REST是轻量级的接口，**服务的提供和调用不存在代码之间的耦合**，只是通过一个约定进行规范，但也有可能出现文档和接口不一致而导致的服务集成问题，但可以通过swagger工具整合，是代码和文档一体化解决，所以REST在分布式环境下比RPC更加灵活

### 3. Spring Boot 和 Spring Cloud

- SpringBoot是Spring推出用于**解决传统框架配置文件冗余，装配组件繁杂的基于Maven的解决方案，旨在快速搭建单个微服务**，**而SpringCloud专注于解决各个微服务之间的协调与配置，服务之间的通信，熔断，负载均衡等**
- 技术维度并相同，并且**SpringCloud是依赖于SpringBoot的**，而SpringBoot并不是依赖与SpringCloud，甚至还可以和Dubbo进行优秀的整合开
- SpringBoot专注于快速方便的开发单个个体的微服务
- SpringCloud是关注**全局的微服务协调整理治理框架**，整合并管理各个微服务，为各个微服务之间提供，配置管理，服务发现，断路器，路由，事件总线等集成服务
  SpringBoot不依赖于SpringCloud，SpringCloud依赖于SpringBoot，属于依赖关系
- **SpringBoot专注于快速，方便的开发单个的微服务个体，SpringCloud关注全局的服务治理框架**

### 4. Eureka和ZooKeeper都可以提供服务注册与发现的功能，请说说两个的区别

- ZooKeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用的（A可用性不强）
- Eureka各个节点是平等关系，只要有一台Eureka就可以保证服务可用，而查询到的数据并不是最新的

- 自我保护机制会导致，Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务，Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点(高可用)，当网络稳定时，当前实例新的注册信息会被同步到其他节点中(最终一致性)
- Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像ZooKeeper一样使得整个注册系统瘫痪
- ZooKeeper有Leader和Follower角色，Eureka各个节点平等
- ZooKeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问
- Eureka本质上是一个工程，而ZooKeeper只是一个进程

### 5. 微服务之间是如何独立通讯的

- 远程过程调用（Remote Procedure Invocation），也就是我们常说的服务的注册与发现，直接通过远程过程调用来访问别的service。
  - 优点：
    - 简单，常见，因为没有中间件代理，系统更简单
  - 缺点：
    - 只支持**请求/响应的模式**，不支持别的，比如通知、请求/异步响应、发布/订阅、发布/异步响应
    - **降低了可用性，因为客户端和服务端在请求过程中必须都是可用的**
- 消息
  - 使用异步消息来做服务间通信。服务间通过消息管道来交换消息，从而通信。
  - 优点:
    - 把**客户端和服务端解耦，更松耦合**
    - 提高可用性，因为消息中间件缓存了消息，直到消费者可以消费
    - 支持很多通信机制比如通知、请求/异步响应、发布/订阅、发布/异步响应
  - 缺点:
    - 消息中间件有额外的复杂性

### 6. 什么是服务熔断?什么是服务降级

- 在复杂的分布式系统中，微服务之间的相互调用，有可能出现各种各样的原因导致服务的阻塞，在高并发场景下，服务的阻塞意味着线程的阻塞，导致当前线程不可用，服务器的线程全部阻塞，导致服务器崩溃，由于服务之间的调用关系是同步的，会对整个微服务系统造成服务雪崩
- 为了解决某个微服务的调用响应时间过长或者不可用进而占用越来越多的系统资源引起雪崩效应就需要进行服务熔断和服务降级处理。
- 所谓的服务熔断指的是某个服务故障或异常一起**类似显示世界中的“保险丝"当某个异常条件被触发就直接熔断整个服务，而不是一直等到此服务超时。**
- 服务熔断就是相当于我们电闸的保险丝，一旦发生服务雪崩的，就会熔断整个服务，**通过维护一个自己的线程池，当线程达到阈值的时候就启动服务降级，如果其他请求继续访问就直接返回fallback的默认值**

### 7. 微服务的优缺点是什么？

- 优点
  - 每一个服务足够内聚，代码容易理解
  - 开发效率提高，一个服务只做一件事
  - 微服务能够被小团队单独开发
  - 微服务是松耦合的，是有功能意义的服务
  - 可以用不同的语言开发，**面向接口编程**，易于与第三方集成
  - 微服务只是业务逻辑的代码，不会和HTML，CSS或者其他界面组合
  - 开发中，两种开发模式
    - 前后端分离
    - 全栈工程师
  - 可以灵活搭配，连接公共库/连接独立库
- 缺点
  - 分布式系统的负责性
  - 多服务运维难度，随着服务的增加，运维的压力也在增大
  - 系统部署依赖
  - **服务间通信成本**
  - **数据一致性**
  - 系统集成测试
  - 性能监控