## 3. 线程间通信

- 轮询间隔小的话，浪费CPU资源，轮询间隔时间大的话，可能取不到想要的结果
- 等待/通知 机制
  - 只能在同步方法中调用wait，将线程放入”预执行队列“
  - wait方法之后，线程释放锁
  - notify 方法也要在同步方法中
  - 执行notify 方法后，线程不会马上释放锁，会执行完同步方法
- 新建一个线程，调用start，线程处于runnable状态，当分配到CPU资源之后，线程进入Running状态
- 每个锁对象有两个队列：
  - 就绪队列：一个线程被唤醒后，进入就绪队列
  - 阻塞队列
- wait(long) 等待一个时间被唤醒，如果超过这个时间还没有被唤醒，则线程自动唤醒
- 假死 就是 全部现场都进入 WATING 状态
- 假死出现的原因可能是连续唤醒同类
  - notify 改为 notifyAll
  - if 判断 改为 while
- 管道进行进程间通信
  - PipeInputStream   PipeOutputStream
  - PipedReader  PipedWriter
  - inputStream.connect(outputStream) 产生通信连接
- 方法join的作用是等待线程对象的销毁
- join 与 wait() 方法区别：
  - join 内部使用 wait() 方法
  - synchronized 内部使用对象监视器原理来同步
- join(long) 方法具有释放锁的特点
- ThreadLocal 主要解决的是每个线程绑定自己的值。
- InheritableThreadLocal 可以在子线程中取得父线程继承下来的值
- 如果子线程在取得旧值的同时，主线程将 InheritableThreadLocal 中的值进行更改，那么子线程取到的值还是旧值