## 2. 对象及变量的并发访问

- 执行synchronized方法，获得该方法所属对象的锁
- get set 需要一起加synchronized，否则会造成脏读
- synchronized 具有可重入锁的功能
- 子类可以通过可重入锁，调用父类的同步方法
- 当线程遇到异常时候，持有的锁会自动释放
- 同步方法不能继承
- synchronized 关键字加到static静态方法上是给类加上锁，加到非静态方法是是给对象加锁，Class锁可以对类的所有对象起作用
- String对象因为存放在常量池里，所以，大多数情况下，synchronized代码块不使用String对象作为锁对象
- 怎样用JDK自带工具判断是否出现死锁
  - jps查看正在运行的java进程
  - jstack 进程号， 查看运行的线程
- 当使用的类和外部类不在一个包里时候，内部类要置为public
- 内部类的new方式 : 外部类.new 
- volatile 与 synchronized 对比
  - volatile 是线程同步的轻量级实现，volatile性能比synchronized要好
  - volatile 只能用于修饰变量，synchronized 性能随着JDK的提升也在提升
  - 多线程访问volatile 不会发生阻塞
  - volatile 只保证可见性，不保证原子性
- AtomicInteger 类， 保证原子性