## 腾讯二面

- Java 虚拟机调优的经历有吗？
- 垃圾回收算法
- 垃圾回收器
  - CMS
  - G1
- **怎么把 client 模式和 server 模式兼得？**
  - 我不会，只是回答了起两个java进程，即起两个虚拟机
- 多线程的同步方式
  - 锁
  - synchronized
  - volatile
- volatile的作用
  - 保证可见性
  - 禁止重排序
- volatile 原理
  - lock 前缀
- AtomicInteger 底层的实现
  - CAS
- CAS是否能替代掉锁
  - 不能，乐观锁
- 读写锁的底层实现？
  - AQS同步队列
  - 先获取写锁可以请求读锁
  - 先获取读锁不能升级为写锁
- **怎样自己实现一个读写锁？（wait/notify）**
  - 获取读锁
    - 写的人 = 0
    - 写请求 = 0
    - 读的人++
  - 获取写锁
    - 没有读写者时候，写的人++
    - 否则：写请求++
  - 释放读锁
    - 读的人--
    - notifyAll
  - 释放写锁
    - 写的人--
    - notifyAll
- Java 中的final
  - 修饰变量：常量
  - 修饰类：该类不能被继承
- **Java 中的 == 和 equals**
  - 基本数据类型 ==
  - 引用类型比较的是内存地址
  - equals 比较对象
  - String中的
    - 直接赋值字符串，== 返回true
    - new，==返回false
- **ArrayList的安全删除**
  - 倒序删
  - 迭代器删（使用迭代器的remove）
  - list.remove + break 删除一个元素
  - CopyOnWriteArrayList  不仅能删，还能加
  - 增强for + break
- TCP 和 UDP的区别
- 为什么是四次挥手
  - 全双工
- **TCP 中的粘包**
  - 发送方原因
    - Nagle算法导致手机多个小分组，在一个确认到达时一起发送
  - 接收方的原因
    - 应用程序读取的速率低于TCP接收分组的速率
  - 解决办法
    - 发送方：
      - 关闭Nagle算法
    - 应用层循环处理
- **TCP中的分包**
  - 原因：
    - IP分片传输
    - 丢失部分包导致半包

- **四次挥手为什么客户端先发起**
  - 按理说谁先发起都行
  - 但是TIME_WAIT到CLOSE之间有两个MSL
  - 服务器的话，这段时间不能重启，否则会显示端口被占用
- 思路设计
  - **uid + score 插入的设计**（没回答上来，我的思路应该不太好）
    - 我的思路是树存分数
    - 一个分数映射多个uid
    - 更新分数时候，在newScore里插入uid，然后遍历比newScore小的子树，删掉其uid
  - 找出前n的人
    - 小顶堆，维护topN
  - 找出比自己高低m的人
    - 二叉搜索树
- 服务需要考虑的因素
  - 安全性
  - 可用性（能取到）
    - 加缓存
    - 备份，冗余
  - 并发性
    - 加缓存
    - 负载均衡
    - 分库分表
    - 读写分离
    - 消息队列（削峰）
  - 可伸缩性
- **什么情况下用关系型数据库，什么情况下不会用**
  - 关系型：
    - 结构化
    - 高事务
  - 非关系型
    - 非结构化
    - 对事务要求不高
    - 扩展性好

