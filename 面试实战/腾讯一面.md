## 腾讯一面

- **Java和C++用起来的差异**
- **Java语言主要担心什么？**
  - 性能
- **怎样写一个Java的程序性能会比较好**
  - 线程池：多线程
  - 虚拟机参数调优
  - JNI 调用 Native 方法
- **碰到性能问题，你会以怎样的思路去解决**
  - 找到性能瓶颈
- **怎样找到性能瓶颈，你平常使用什么工具**
  - 资源管理器
  - JConsole
  - VirtualVm

- **-client -server的差异**

  - client的加载速度比server模式快百分之10，但是运行速度是server模式的十分之一，堆默认：1M~64M。使用轻量级的c1编译器
  - server模式针对服务器应用，堆默认128M~1G。使用重量级的c2编译器

- **Java中怎么排查是哪个线程出现了问题**

  - top 查看吃资源多的 Java 进程
  - top -H -p 【进程号】查看某个进程内部的线程  （或者使用jps）
  - linux上的sun jvm将java程序中的线程映射为了操作系统进程
  - jstack 【进程号】 > stack.log 生成Java线程的dump
  - 或者采用 JConsole 或者 VirtualVM 分析 dump 文件
  - 核心还是分析Dump文件

- **Java中的垃圾回收算法**

  - 标记清除（整理）
  - 复制 

- **Java中的垃圾收集器**

  - CMS
  - G1

- **介绍一下CMS垃圾收集器**

  - CMS只回收老年代和方法区，不回收新生代
  - 预回收垃圾收集器，需要在old的内存耗尽之前，就进行垃圾回收。阈值，老年代或者永久带达到百分之92%，否则会使用串行老年代收集，会产生STW
  - -XX:CMSFullGCsBeForeCompaction 指定多少次CMS之后进行一次压缩，防止碎片化
  - 阶段
    - 初始标记：STW 并行
      - 标记老年代到GC Roots的对象
        - Java中可以作为GC Roots引用的对象
          - 虚拟机栈帧中局部变量表引用的对象
          - 方法区中类静态属性引用的对象
          - 方法区中常量引用的对象
          - 本地方法栈中JNI的引用对象
      - 标记新生代中活着的对象引用的老年代的对象
      - 如何加速此阶段：
        - -XX:+CMSParallelInitialMarkEnable 开启并行标记，同时调大并行标记的线程数
    - 并发标记：并发
      - 从初始标记阶段标记的对象去寻找存活的对象
        - 重新标记Dirty
    - 重新标记：STW 并行
      - 扫描整个堆，清理掉年轻的中不可达的对象
    - 并发清理：并发
      - 会产生浮动垃圾

- **介绍一下G1垃圾收集器：**

  - 首先尽可能多的收集垃圾
    - 不会等要消耗干净了再收集，而是收集高收益的
    - 根据用户设定暂停空间自动设置年轻代大小，暂停时间越短，年轻带越小，总空间越大
  - 内存采用分区的思路，以分区进行回收，天然具有压缩特性
  - 只是逻辑上具有分代的概念

- **GC算法怎么判断哪些是需要回收，哪些是不需要回收的？**

  - GC Roots 可达性分析
    - 函数栈中有没有引用
    - 方法区的全局变量有没有引用
    - 方法区的静态变量有没有引用
    - 栈上的变量有没有引用

- **JVM的 Java Call的过程（方法调用的过程）** 

  - 解析（invoke**）
    - 解析的过程就是：符号引用->直接引用
    - 符合编译期可知，运行期不变的包括静态方法和私有方法
    - 虽然final方法是invokevirtual指令来调用，但是它是非虚方法
    - 只要能被invokestatic和invokespecial方法调用的方法都可以在解析的时候确定其唯一的调用版本。符合这个条件的有静态方法、私有方法、父类方法、构造器方法

  - 分派
    - 静态分派
      - 重载时是根据参数的静态类型
      - 重载时自动类型转换优先级高于自动装箱
      - 可变长参数的重载优先级是最低的
      - 根据多个宗量来进行选择，是多分派类别
    - 动态分派——重写
      - invokevirtual执行的第一步就是确定所指向对象的实际类型
      - 如果没找到，就按照继承关系从下往上找
      - 单分派
      - 为了提高性能，防止频繁搜索，会在方法区建立  **虚方法表**，使用虚方法表索引来代替元数据以提高性能
      - 方法表一般会在类加载的连接阶段进行初始化

- **JVM如何触发热点代码的编译**

  - 方法计数器
  - 回边计数器

- **消息队列有什么好处？**

  - 异步
  - 解耦
  - 消除峰值

- **消息队列的坏处**

  - 系统的可用性降低：引入外部依赖越多，越容易挂掉
  - 系统复杂性提高
  - 一致性问题

- **为什么使用ES？为什么ES比MySQL检索快**

  - ES采用Lucene **倒排索引** 技术
  - 对多条件过滤效果好
  - b-tree是写入优化

- **算法题：**

  - 数组去掉零
    - 我的做法`nums[count++] = nums[i]`，但是带来的问题是如果0少，则交换次数特别多
    - 零少的情况把0和数组末尾进行交换

- **Java中的强弱软虚四种引用**

  - 强引用：不会被GC，new
  - 软引用（SoftReference）：内存空间不够了才GC，可以和 ReferenceQueue 一起使用
  - 弱引用（WeakReference）：一旦发现了只具有弱引用的对象，都会立刻回收
  - 虚引用（PhantomReference）：必须和 ReferenceQueue 一起用
  - ReferenceQueue 可以判断对象是否被GC
  - 软引用+引用队列可以用来做缓存
  - WeakHashMap 会自动GC掉不用的key

- **弱引用+引用队列构建缓存系统**

  - 引用队列的作用是判断弱引用是否还存活
  - 有一个map，value来保存对象的弱引用
  - 循环遍历引用队列，删除掉弱引用
  - 弱引用.get() 重新获取弱引用

- **System.gc() 是立刻调用吗？**

  - 不会，只是建议

