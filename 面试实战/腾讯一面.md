## 腾讯一面

- **Java和C++用起来的差异**
- **Java语言主要担心什么？**
  - 性能
- **怎样写一个Java的程序性能会比较好**
  - 线程池：多线程
  - 虚拟机参数调优
  - JNI 调用 Native 方法
- **碰到性能问题，你会以怎样的思路去解决**
  - 找到性能瓶颈
- **怎样找到性能瓶颈，你平常使用什么工具**
  - 资源管理器
  - JConsole
  - VirtualVm

- **-client -server的差异**
  - client的加载速度比server模式快百分之10，但是运行速度是server模式的十分之一，堆默认：1M~64M。使用轻量级的c1编译器
  - server模式针对服务器应用，堆默认128M~1G。使用重量级的c2编译器
- **Java中怎么排查是哪个线程出现了问题**
  - top 查看吃资源多的 Java 进程
  - top -H -p 【进程号】查看某个进程内部的线程
  - linux上的sun jvm将java程序中的线程映射为了操作系统进程
  - jstack 【进程号】 > stack.log 生成Java线程的dump
  - 或者采用 JConsole 或者 VirtualVM 分析 dump 文件
  - 核心还是分析Dump文件
- **Java中的垃圾回收算法**
  - 标记清除（整理）
  - 复制 
- **Java中的垃圾收集器**
  - CMS
  - G1
- **介绍一下CMS垃圾收集器**
  - CMS只回收老年代和方法区，不回收新生代
  - 预回收垃圾收集器，需要在old的内存耗尽之前，就进行垃圾回收。阈值，老年代或者永久带达到百分之92%，否则会使用串行老年代收集，会产生STW
  - -XX:CMSFullGCsBeForeCompaction 指定多少次CMS之后进行一次压缩，放置碎片化
  - 阶段
    - 初始标记：STW 并行
      - 标记老年代到GC Roots的对象
        - Java中可以作为GC Roots引用的对象
          - 虚拟机栈帧中局部变量表引用的对象
          - 方法区中类静态属性引用的对象
          - 方法区中常量引用的对象
          - 本地方法栈中JNI的引用对象
      - 标记新生代中或者的对象引用的老年代的对象
      - 如何加速此阶段：
        - -XX:+CMSParallelInitialMarkEnable 开启并行标记，同时调大并行标记的线程数
    - 并发标记：并发
      - 从初始标记阶段标记的对象去寻找存活的对象
        - 重新标记Dirty
    - 重新标记：STW 并行
      - 扫描整个堆，清理掉年轻的中不可达的对象
    - 并发清理：并发
      - 会产生浮动垃圾
- 介绍一下G1垃圾收集器：
  - 首先尽可能多的收集垃圾
    - 不会等要消耗干净了再收集，而是收集高收益的
    - 根据用户设定暂停空间自动设置年轻代大小，暂停时间越短，年轻带越小，总空间越大