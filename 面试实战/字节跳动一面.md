## 字节跳动一面

### 算法题一

- `2*1`的砖填满`2*n`的面积，方法种数
  - 斐波那契数列

### 算法题二

- 求二维数组中是否存在某个数，不能用遍历，二维数组的右边比左边大，下边比上边大
  - 变相的二分查找法

### 思路题一

- 100亿个无符号整数，选出前100
  - 堆排序
  - 归并排序-交给多线程去处理
  - 构建堆的复杂度O(n)
  - 堆排序：O(nlogn)
  - 插入堆：O(logn)
    - 用前100个数建成小顶堆，然后顺序读入后面的数一次跟堆顶元素比较，如果大于堆顶元素，就替换，然后做min-heapify。空间复杂度O(M),时间复杂度O(NlgM),N就是100亿，M是100
    - 位图数组法：空间换时间

### 数据库

- **索引的结构**
  - B+树
- **为什么用B+树**？
  - 索引本身很大，不可能全部放在内存里
  - 评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中，磁盘IO操作次数的渐进复杂度
  - B+树在读取相同的磁盘块时，能加载更多的索引数据
  - B+树的数据只存储在叶子节点中，每个基础节点存储的关键字更多，树的层级更少，查询速度更快
  - 所有的查询都要查询到叶子节点，查询性能更稳定
  - 所有叶子节点形成链表，便于范围查询
- **B+树的结构**
  - 为了提高查询效率，要把树变得矮胖
  - B+树的双亲节点会在孩子节点里出现
  - B+树孩子叶子节点用指针相连，形成一个链表
  - 叶子节点包含了全部节点

### 计算机网络

- **浏览器从输入域名，到拿到结果的整个过程**？
  - 查DNS，缓存，ISP的DNS
  - 三次握手，TCP连接建立
  - 浏览器发送GET请求
    - URL
    - User-Agent 浏览器操作系统信息
    - 请求头等
  - 显示页面或者返回其他
    - 浏览器根据Content-Type进行解析渲染
    - 重定向：301，302
      - 301 永久重定向，可以缓存
      - 302 暂时重定向
- **GET和POST的本质区别**？
  - GET参数放在URL里，更不安全，POST放在request body里面
  - GET产生一个TCP数据包，POST产生两个TCP数据包
    - GET发送header和data，返回200
    - POST发送header，返回100 continue，再发送data，返回200 OK  （firefox只发送一次）
- **讲一下HTTPS**？
  - HTTP先与SSL通信，SSL再与TCP通信
  - 对称加密和非对称加密混合
    - 对称加密速度快，但是秘钥无法安全给对方
    - 非对称加密速度慢，但是秘钥可以安全给对方
  - 公钥加密对称加密的秘钥

### 信息安全

- **什么是对称加密，什么是非对称加密**？
  - 对称加密：加密和解密秘钥相同
  - 非对称加密：加密和解密秘钥不相同
- **证书的本质是什么**？
  - 公钥，只要证书是可信的，公钥就是可信的
- **对称加密算法，说几个**
  - AES
  - DES
  - RC5

### 操作系统

- **IO模型**
  - 阻塞IO
  - 非阻塞IO
  - 多路复用IO：select函数，poll函数，epoll函数
  - 信号驱动IO
  - 异步IO
- **线程和进程的区别：**
  - 进程：
    - 进行资源调度和分配的独立单元
  - 线程：
    - 线程是CPU调度和分派的基本单位
  - 一个进程可以拥有多个线程，多个线程之间也可以并发访问
- **线程之间的共享资源有哪些？独享资源有哪些**
  - 共享：
    - 堆
    - 全局，静态变量
    - 文件
  - 独享：
    - 栈
    - 寄存器，PC
- **什么是协程**？
  - 微线程
  - 可以中断子程序去运行其他子程序
  - 执行效率高，没有线程切换
  - 不需要多线程的锁机制
  - 多进程+协程可以充分利用多核资源

### Nginx

- **Nginx 速度快的原因？**
  - 异步非阻塞
  - epoll模型
- **补充：select、poll、epoll之间的区别？**
  - select：轮询，最大连接1024 O(n)  同步，自己读写数据
  - poll：轮询，没有最大连接数，基于链表来存储 O(n)  同步，自己读写数据
  - epoll：事件驱动，O(1)  异步

### Java

- **垃圾回收过程**
  - 可达性分析算法
  - 分代收集算法
    - 新生代：复制：朝生夕死，付出少量的内存作为代价进行回收
    - 老年代：标记整理：有碎片
- **HashMap数据结构**
  - JDK 1.7 
  - JDK 1.8 改为红黑树，8个以下是链表存储
- **JDK1.8 中，HashMap的底层实现为什么改成红黑树**
  - 加快检索速度O(LogN)
- **红黑树的结构及优点**
  - 结构：
    - 根节点是黑的，叶子节点是黑的
    - 如果节点是红的，子节点必须全部是黑的
    - 每一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点
    - 通过颜色变换和节点旋转调整平衡
  - 优点
    - AVL树解决平衡问题，O(LogN)
    - 红黑树不像AVL树一样追求绝对的平衡，允许局部很少的不平衡，省去了很多调平衡的代价
    - 插入删除操作提高了很多

### 缓存

- **缓存击穿解决方案**
  - key的value设置为null
- **缓存失效高并发下的解决方案**
  - 加锁：降低吞吐量
  - 失效时间加随机值
  - 多级缓存：一个缓存未命中，加锁去数据库更新，其他去另一个缓存里取数据（最优）

### 项目

- **做项目的过程中遇到的最困难的问题**
- **介绍自己做的项目**

### Vue

- **Vue是怎么监听数据变化的**
  - watch监听数据变化
  - 底层观察者模式
  - 底层调用了核心监听方法Object.defineProperty()函数
- **v-model 的实现原理**
  - V-bind 绑定响应式数据
  - 出发input事件，并且传递数据

### JS

- **null和undefined的区别**
  - null：特殊的变量类型，程序级
  - undefined：未赋值，系统级

### 设计模式

- **装饰器模式应用场景**
  - 为现有的对象动态增加新的功能
  - 比起继承更加灵活，减少了子类爆炸增长的问题
- **适配器模式**
  - 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作

### 