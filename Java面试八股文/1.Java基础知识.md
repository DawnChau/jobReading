- Integer和int的区别
  - Integer存储在堆上，int存储在栈上
- IntegerCache
  - 范围是-128~127
  - 采用的是享元模式
  - 享元模式的思想是空间换时间
  - ThreadLocal，本地缓存等都是享元模式
- new String("hello")
  - 如果hello这个字符串常量不存在，会创建两个对象，一个放到常量池里，一个是new的实例对象
  - 如果hello这个字符串已经存在，则只会创建new出来的实例对象
- intern()方法
  - 能使一个位于对中的字符串，在运行期间动态的加入字符串常量池，并返回该字面量在字符串常量池中的引用
- String值的不可变性
  - value是final修饰的，不可变，每次修改String的值都会产生一个新的对象
- StringBuilder和StringBuffer都派生自抽象类AbstractStringBuilder
- 克隆
  - 原型模式
- 浅克隆举例：
  - 工具类提供
    - Spring提供的BeanUtils
    - Apache提供的PropertyUtils
  - 实现Cloneable接口
  - Arrays的copyOf方法
- 深克隆举例：
  - 重写Clone方法
  - 序列化
  - Apache提供的SerializationUtils.clone
  - 通过JSON工具类实现深克隆
  - 通过构造方法，也就是new实现深克隆
- 虚引用：
  - 垃圾回收器在回收一个对象时，如果发现它有虚引用，会把虚引用加入到引用队列里，程序可以通过判断引用队列里是否已经被加入虚引用来决定对象是否要被垃圾回收器回收，然后，可以在引用对象被回收之前做些事情
  - 虚引用必须和引用队列一起使用
- 一个空Object占据多大内存
  - 对象头：
    - MarkWord占用8字节（64位系统中）
    - 类元指针（指向当前实例属于哪个类）：开启指针压缩4字节，未开启8字节
    - 数组信息：对象是是数组才会有，存储数组长度，4字节
- 空对象由于对齐填充的原因，不管有没有开启指针压缩，都会占用16个字节的存储空间
- 为什么重写equals一定要重新hashcode
  - HashMap等Hash类的集合，如果用equals，效率太低，会优先用hashCode，当hashCode相同时，再调用equals
  - 如果只重写equals，会导致两个对象equals，但是hashCode不相同，在使用Hash类集合时会有问题，会出现悖论
- 异常
  - 受检异常：需要显式catch或者throws
  - 非受检异常：不需要显式catch
    - Error和RuntimeException是非受检异常
- fail-fast和fail-safe的区别
  - 是多线程并发操作集合时的失败处理机制
  - fail-fast：快速失败
    - java.util：HashMap，ArrayList
  - fail-safe:失败安全
    - juc包下边：ConcurrentHashMap，CopyOnWriteArrayList
- 反/序列化：
  - 就是把内存对象转换为字节流，以便实现存储或者传输
  - 反序列化：从文件或者网络中获取对象的字节流，重新构建对象
- 序列化关注的问题：
  - 序列化之后数据的大小
  - 序列化的性能
  - 是否支持跨平台，跨语言
- SPI
  - 举例：java.jdbc.Driver
- finally在什么情况下不会执行
  - 程序没有进入try
  - 在try或者catch里执行了System.exit(0)，导致JVM退出