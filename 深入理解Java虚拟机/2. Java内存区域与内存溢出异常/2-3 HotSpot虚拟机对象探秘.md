## 2-3 HotSpot虚拟机对象探秘

### 2-3-1 对象的创建

- 创建对象的三种方法：
  - new
  - 克隆
  - 反序列化

- new指令的执行
  - 首先回去检查这个指令的参数能否在常量池中定位到一个类的符号引用。
  - 检查这个符号引用是否已被加载解析和初始化过
  - 如果没被加载过，执行类加载的过程
- 类加载的过程
  - 为新生对象分配内存，对象所需内存的大学在类加载完成后便可以完全确定
    - 分配内存的两种方式：
      - 指针碰撞：指针向后挪动一段与对象大小相等的距离。
      - 空闲列表：找一些内存碎片进行分配
    - Serial，ParNew等带Compact过程的收集器，系统采用的分配算法是指针碰撞
    - 使用CMS这种基于Mark-Sweep算法的收集器时，采用空闲列表
  - 为对象分配内存时候的同步处理
    - 一种方式是CMS配上失败重试的方式保证更新操作的原子性
    - 一种方式是把内存分配在TLAB本地线程分配缓冲上，只有TLAB用完了且需要分配新的TLAB时，才需要同步锁定
    - 虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定
  - 内存分配完成后，虚拟机会把所有的内存空间都初始化为零值
    - 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行
  - 接下来虚拟机会对对象进行必要的设置，信息存放在对象头里
    - 这个对象是哪个类的实例
    - 如何才能找到这个类的元数据信息
    - 对象的哈希码
    - 对象的GC分代年龄
  - 一般来说，执行完new指令之后，会接着执行<init>方法，来根据程序员的意愿进行初始化



### 2-3-2 对象的内存布局

- 对象头
  - 运行时数据：如哈希码，GC分代年龄，锁状态等
  - 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
    - 如果对象是一个Java数组，那么在对象头中还必须优衣库用于记录数组长度的数据
  
- 实例数据

- 对齐填充

  - 对象的大小必须是8字节的整数倍

    

### 2-3-3  对象的访问定位

- 句柄（Java堆中会划分出一块作为句柄池）
  - 对象移动的时候只需要改变句柄中的实例指针（垃圾收集时移动对象是非常普遍的事情）
- 直接指针（HotSpot采用该方式）
  - 速度快