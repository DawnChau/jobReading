## 2-4 实战：OutOfMemoryError异常

### 2-4-1 Java堆溢出

- -Xms和-Xmx设置为一样，即可避免堆自动扩展
- -XX：HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出是Dump当前内存堆转存储快照
- 内存泄露和内存溢出的区别
  - 内存泄露中，内存对象是无用的
    - 同过查找GC Root引用链，想办法断开
  - 内存溢出：内存对象是有用的，只是超出了堆的限制
    - 设置-Xms和-Xmx，查看能否进一步扩大



### 2-4-2 虚拟机栈和本地方法栈溢出

- -Xss 设置方法栈大小
- 如何制造栈溢出？
  - 通过模拟递归
- 单线程下，无论是由于栈帧太大还是虚拟机容量太小，内存无法分配时候，抛出的都是stackOverFlow异常
- 多线程场景下为什么也会使得栈溢出？
  - 因为栈里分配的数据是线程私有的，每当一个新的线程产生，都会在栈分配一部分数据



### 2-4-3 方法区和运行时常量池溢出

- JDK1.6之前，常量池分布在永久带
  - -XX:PermSize和-XX:MaxPermSize来限制方法区的大学

- Spring.intern() 是Native方法，作用是：
  - 常量池包含一个等于此String的字符串，返回
  - 否则，将此String对象包含的字符串加入常量池，并返回引用
- JDK 1.7  的 intern()，如果该字符串是首次出现，不会复制，只会在常量池里放引用
- JDK 1.6 的 intern()会复制，因此返回的不是同一个对象

- 方法区里的类信息太多导致的溢出
  - CGlib字节码增强，动态生成的Class可能会导致方法区溢出
  - JSP动态生成的类文件
  - OSGI：不同的类加载器加载同一个类文件，也被认为是不同的类



### 2-4-4 本机直接内存溢出

- 可以通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java对最大值，-Xmx一样
- Unsafe类的getUnsafe方法限制了只有引导类加载器才会返回示例，设计者希望只有rt.jar中的类才能使用Unsafe的功能
  - 直接分配内存的方法是unSafe.allocateMemory

- 明显特征是Heap Dump中不会看到异常
  - Dump文件很小
  - 程序间接使用了NIO