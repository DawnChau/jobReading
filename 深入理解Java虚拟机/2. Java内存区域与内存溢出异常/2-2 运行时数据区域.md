## 运行时数据区域

### 2.2.1 程序计数器

- 当前线程所执行的字节码的行号指示器s

- 线程私有

- 执行native方法时，程序计数器为空

- 是唯一一个在Java虚拟机规范中没有定义OutOfMemory异常的区域

  

### 2.2.2 Java虚拟机栈（方法栈）

- 线程私有，生命周期与线程相同
- 我们通常所描述的栈，就是讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分
- 栈帧中有局部变量表，在编译期完成分配，但是栈帧的分配是运行期函数执行时分配的
- 局部变量表中，64位的long和double会占用两个Slot
- 当线程请求的栈深度大于虚拟机栈所允许的深度时，会抛出栈溢出异常。当扩展还无法满足时候，会抛出OOM异常



### 2.2.3 本地方法栈

- 虚拟机栈执行java方法，本地方法栈执行native方法
  - 甚至有的虚拟机吧本地方法栈和虚拟机栈合二为一，如Sun HotSpot

- 同方法栈



### 2.2.4 堆

- 线程共享
  - 线程共享的堆中可能划分出多个线程私有的分配缓冲区TLAB（Thread Local Allocation Buffer）
- 可扩展，通过-Xmx和-Xms来控制



### 2.2.5 方法区（非堆）（永久带）

- 方法区是JVM的规范，永久带是HotSpot对方法区的一个老式实现

- 存放类信息，常量，静态变量，即时编译后的代码等数据
- 很多人愿意把方法区称为永久带，因为Hot Spot把GC分代收集扩展至方法区。
  - 用永久带来实现方法区并不是一个好的实现，更容易遇到内存溢出的问题
  - 永久带有-XX:MaxPermSize的上限

- 线程共享
- 放类信息，常量，静态变量
- HotSpot已经决定用Native Memory来实现方法区了
- Jdk1.7中，常量池被移出永久带
- 永久带的垃圾回收主要是做常量池的回收和类型的卸载
- 根据JVM规范，方法区如果无法满足内存分配的要求，要抛出OOM



### 2.2.6 运行时常量池

- 方法区的一部分
- 运行期间也可以将新的常量放入池中

### 2.2.7 直接内存

- NIO是基于通道和缓冲区的IO方式，可以通过native函数库直接分配堆外内存
- 通过DirectByteBuffer可以作为这块内存的引用进行操作。