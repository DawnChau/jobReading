## 8-3 方法调用

- 方法调用并不是方法执行，只是确定接下来执行哪个方法

### 8-3-1 解析

- 解析的过程就是：符号引用->直接引用

- 符合编译期可知，运行期不变的包括静态方法和私有方法
- 虽然final方法是invokevirtual指令来调用，但是它是非虚方法
- 只要能被invokestatic和invokespecial方法调用的方法都可以在解析的时候确定其唯一的调用版本。符合这个条件的有静态方法、私有方法、父类方法、构造器方法

### 8-3-2 分派

- 静态分派
  - 重载时是根据参数的静态类型
  - 重载时自动类型转换优先级高于自动装箱
  - 可变长参数的重载优先级是最低的
  - 根据多个宗量来进行选择，是多分派类别
- 动态分派——重写
  - invokevirtual执行的第一步就是确定所指向对象的实际类型
  - 如果没找到，就按照继承关系从下往上找
  - 单分派
  - 为了提高性能，防止频繁搜索，会在方法区建立  **虚方法表**，使用虚方法表索引来代替元数据以提高性能
  - 方法表一般会在类加载的连接阶段进行初始化

###  8-3-3 动态类型语言支持

- 运行时异常就是只要代码不运行到这一行就不会有问题
- Refection和MethodHandler机制的区别：
  - 反射是java层次，重量级
  - MethodHandler是字节码层次，轻量级
- MethodHandler用法
  - 先用MethodType获取返回值类型
  - 使用lookup()等方法返回MethodHandler
  - 调用invoke