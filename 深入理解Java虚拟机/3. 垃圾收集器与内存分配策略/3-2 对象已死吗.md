## 3-2 对象已死吗

### 3-2-1 引用计数法

- 虚拟机不使用，原因是无法解决循环引用的问题

  

### 3-2-2 可达性分析算法

- 虚拟机采用可达性分析来判断对象是否存活

- GC Roots是一个引用链子，如果对象没有和GC Roots产生关联，则说明该对象是不可用的

- GC Roots
  - 虚拟机栈栈（栈中的本地变量表）中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - Native方法引用的对象
  
  

### 3-2-3 再谈引用

- 强引用（new），gc永不回收
- 软引用，内存快溢出才回收-->缓存，guava-cache
- 弱引用，垃圾回收就回收
- 虚引用：没啥卵用。但是：为一个对象设置虚引用，可以在对象被垃圾回收的时候收到一个系统通知



### 3-2-4 生存还是死亡

- 和GC Root失去联系后，第一次标记，判断是否覆盖finalize()，或者虚拟机是否调用过finalize()，上述都为没必要执行，直接干掉
- 若是有必要执行，则执行，放置到F-Quene队列中，由低优先级的Finalizer线程来执行其finalize()方法。
  - 所谓的执行，是指虚拟机会触发这个方法，但是不承诺等它运行结束
  - 可以做最后一次自我挽救，让引用 = this。
- 不鼓励大家使用finalize()，忘了吧

- 任何一个对象的finalize方法只会被调用一次



### 3-2-5 回收方法区

- 无用的类
  - 该类所有的实例都被回收
  - 该类的类加载器被回收
  - 该类的Class对象没有在任何地方被引用，无法通过反射创建该对象