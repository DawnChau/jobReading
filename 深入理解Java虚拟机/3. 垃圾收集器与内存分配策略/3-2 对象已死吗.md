## 3-2 对象已死吗

### 3-2-1 引用计数法

- 虚拟机不使用，原因是无法解决循环引用的问题

### 3-2-2 可达性分析算法

- 虚拟机采用可达性分析来判断对象是否存活
- GC Roots
  - 方法栈中引用的对象
  - 方法区中静态属性引用的对象
  - 方法区中常量引用的对象
  - Native方法引用的对象

### 3-2-3 再谈引用

- 强引用（new），gc永不回收
- 软引用，内存快溢出才回收
- 弱引用，垃圾回收就回收
- 虚引用：没啥卵用

### 3-2-4 生存还是死亡

- 和GC Root失去联系后，第一次标记，判断是否覆盖finalize()，或者虚拟机是否调用过finalize()，上述都为没必要执行，直接干掉
- 若是有必要执行，则执行，放置到F-Quene队列中，由Finalizer线程来执行其finalize()方法。可以做最后一次自我挽救，让引用 = this。
- 不鼓励大家使用finalize()，忘了吧

### 3-2-5 回收方法区

- 无用的类
  - 该类所有的实例都被回收
  - 该类的类加载器被回收
  - 该类的Class对象没有在任何地方被引用，无法通过反射创建该对象