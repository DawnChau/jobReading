## 7-2 类加载的时机

- 生命周期
  - 加载
    - 通过类的全限定名获取该类的字节流
    - 将静态存储结构转化为方法区的运行时数据结构
    - 在Java堆中生成Class对象，作为方法区数据的访问入口
  - 验证
  - 准备
    - 为类变量分配内存并且初始值为0
  - 解析：开始时间可以在初始化之后
    - 将符号引用转化为直接引用
  - 初始化
    - 初始化的过程其实就是一个执行类构造器`<clint>`方法的过程
  - 使用
  - 卸载
- 五种情况需要立刻初始化
  - 遇到new、getstatic、putstatic、invokestatic指令。读取或者设置final修饰的静态字段不会触发初始化，因为final字段在编译期把结果放入了常量池。
  - reflect反射调用
  - 如果父类没有初始化，先初始化父类
  - 虚拟机启动时，会先初始化主类
- 被动引用
  - 子类使用父类的静态字段，子类不会初始化。直接定义该静态字段的类才会被初始化。
  - 通过数组定义来引用类，不会触发该类的初始化
  - 常量在编译阶段会存入调用类的常量池，引用常量不会触发初始化。
  - 一个接口在初始化的时候，并不要求其父类接口必须全部初始化，只有在真正使用到父接口时候，才会初始化。
  - 引用接口中定义的常量会触发接口的初始化。
- 当类构造器的`<clint>`方法执行完后，接着执行的就是实例构造器的`<init>`方法
- 初始化顺序：
  - 父类静态对象和静态代码块 
  - 子类静态对象和静态代码块 
  - 父类非静态对象和非静态代码块 
  - 父类构造函数 
  - 子类 非静态对象和非静态代码块 
  - 子类构造函数
- **类构造器的<clint>一般情况下只会执行一次，而类的实例构造器的<init>方法只要有申请一个对象就会执行**