## 12-3 Java内存模型

### 12-3-2 内存间交互操作

-  在对一个变量进行lock的时候，会先清空工作内存中此变量的值，执行引擎使用这个变量前，需要重新执行load活assign操作初始化变量的值

### 12-3-3 对于volatile型变量的特殊规则

- volatile能保证可见性，但是并不能保证同步。因为虽然volatile改变是瞬间可见的，但是，当volatile变量被放到操作数栈，进行加一时候，其他线程可能已经把这个值增加了。必须加锁才能保证原子性
- volatile 适用于做多线程下的标志位
- volatile能够保证可见性和禁止指令重排序的根本原因
  - `lock addl $0x0` lock+空操作，作用是使得cache写回内存
  - 所以具有可见性
  - 由于写回内存前和写回内存后是两个阶段，所以前后两阶段的指令不可能重排序。
- volatile 写操作会慢，因为要插入内存屏障

### 12-3-5 原子性、可见性与有序性

- 原子性
  - volatile
- 可见性：
  - final
  - synchronized
  - volatile
- 有序性：
  - synchronized
  - volatile

### 12-3-6 先行发生原则

- Thread.join() 方法可以结束线程
- 并发安全问题不要受到时间顺序的干扰，一切以先行原则为准